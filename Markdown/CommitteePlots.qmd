---
title: "Thesis Plots (4/15)- for Committee Meeting"
author: Jackson Barnett 
format: html
editor: visual
---

```{r setup, include = FALSE}

knitr::opts_chunk$set(
  echo = FALSE,      # Hide the code
  warning = FALSE,   # Suppress warnings
  message = FALSE    # Suppress messages
)

```

```{r}
library(tidyverse)
library(kableExtra)
library(ggplot2)
library(car)
library(patchwork)
library(dplyr)
library(gridExtra)
library(tidyr)

```

```{r}

fullthesisurl <- "https://docs.google.com/spreadsheets/d/e/2PACX-1vSzc4O_yfQyjR6m0xebm0MWcQ58v-aMF1cq1zDVMJ9Qs-tGrgf94j21Ood2xGH-f5hw-gC8CqpjenBO/pub?gid=2008970607&single=true&output=csv"

fullthesis <- read_csv(fullthesisurl)

```

```{r}
long_data <- fullthesis %>%
  pivot_longer(cols = c(`kd`, `CDOM`, `TSS`, `CHLa`), 
               names_to = "Variable", 
               values_to = "Value") %>%
  mutate(
    Variable = factor(
      Variable,
      levels = c("kd", "CDOM", "TSS", "CHLa")  # Set the desired order
    ),
    Site = dplyr::recode(Site, 
                         "2-BRI010.78" = "BRI_1",
                         "2-BRI013.12" = "BRI_2",
                         "5ANTW127.14" = "Barfoot",
                         "2-CHK026.94" = "Chick",
                         "Harrison Near Dam" = "Harrison",
                         "2-SDY004.27" = "SDY_1",
                         "2-SDY005.85" = "SDY_2",
                         "2-MBN000.96" = "SDY_3",
                         "2-SFT031.08" = "SFT_1",
                         "2-DYC000.19" = "SFT_2",
                         "2-SFT033.42" = "SFT_3",
                         "2-SFT034.38" = "SFT_4",
                         "Lake Anna Dam Surface" = "ANNA")
  )

# Define the specific order for Site levels
site_order <- c("Barfoot", "Harrison", "Chick", "SFT_4", "SFT_3", "SFT_2", "SFT_1", "SDY_2", "BRI_2", "SDY_1",  "SDY_3", "BRI_1", "ANNA")

# Update the long_data to apply the specific Site order
long_data <- long_data %>%
  mutate(Site = factor(Site, levels = site_order))  # Set the levels of Site


```

## All data ANOVAs

```{r}


# Define custom y-axis titles (units) for each variable
custom_y_labels <- c(
  `kd` = "kd (m⁻¹)",
  `CDOM` = "CDOM (m⁻¹)",
  `TSS` = "TSS (mg L⁻¹)", 
  `CHLa` = "CHLa (µg L⁻¹)"
)

# Create individual plots for each variable
plot_kd <- ggplot(subset(long_data, Variable == "kd"), aes(x = Site, y = Value)) +
  geom_boxplot(outlier.color = "red", outlier.shape = 16, fill = "lightblue") +
  labs(
    title = NULL,
    x = NULL,
    y = custom_y_labels["kd"]
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 6),  # Change x-axis text size to 4
    axis.text.y = element_text(size = 8),
    axis.title.y = element_text(size = 10),
    panel.border = element_rect(color = "black", fill = NA, size = 1)  # Add box around chart area
  )

plot_CDOM <- ggplot(subset(long_data, Variable == "CDOM"), aes(x = Site, y = Value)) +
  geom_boxplot(outlier.color = "red", outlier.shape = 16, fill = "lightblue") +
  labs(
    title = NULL,
    x = NULL,
    y = custom_y_labels["CDOM"]
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 6),  # Change x-axis text size to 4
    axis.text.y = element_text(size = 8),
    axis.title.y = element_text(size = 10),
    panel.border = element_rect(color = "black", fill = NA, size = 1)  # Add box around chart area
  )

plot_TSS <- ggplot(subset(long_data, Variable == "TSS"), aes(x = Site, y = Value)) +
  geom_boxplot(outlier.color = "red", outlier.shape = 16, fill = "lightblue") +
  labs(
    title = NULL,
    x = NULL,
    y = custom_y_labels["TSS"]
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 6),  # Change x-axis text size to 4
    axis.text.y = element_text(size = 8),
    axis.title.y = element_text(size = 10),
    panel.border = element_rect(color = "black", fill = NA, size = 1)  # Add box around chart area
  )

plot_CHLa <- ggplot(subset(long_data, Variable == "CHLa"), aes(x = Site, y = Value)) +
  geom_boxplot(outlier.color = "red", outlier.shape = 16, fill = "lightblue") +
  labs(
    title = NULL,
    x = NULL,
    y = custom_y_labels["CHLa"]
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 6),  # Change x-axis text size to 4
    axis.text.y = element_text(size = 8),
    axis.title.y = element_text(size = 10),
    panel.border = element_rect(color = "black", fill = NA, size = 1)  # Add box around chart area
  )

# Arrange the plots in a grid layout
grid.arrange(plot_kd, plot_CDOM, plot_TSS, plot_CHLa, ncol = 2)


```


```{r}

library(multcompView)

# Function to get letter labels
get_letters <- function(variable_name) {
  model <- aov(Value ~ Site, data = subset(long_data, Variable == variable_name))
  tukey <- TukeyHSD(model)
  letters <- multcompLetters4(model, tukey)
  letter_df <- as.data.frame.list(letters$Site)
  letter_df$Site <- rownames(letter_df)
  names(letter_df)[1] <- "Letter"
  return(letter_df)
}

# Generate letter labels for each variable
kd_letters <- get_letters("kd")
cdom_letters <- get_letters("CDOM")
tss_letters <- get_letters("TSS")
chla_letters <- get_letters("CHLa")


```

```{r}

# Function to get max value for positioning labels
get_site_max <- function(variable_name) {
  subset(long_data, Variable == variable_name) %>%
    group_by(Site) %>%
    summarise(Max = max(Value, na.rm = TRUE))
}

kd_max <- get_site_max("kd")
cdom_max <- get_site_max("CDOM")
tss_max <- get_site_max("TSS")
chla_max <- get_site_max("CHLa")


```

```{r}

kd_labels <- merge(kd_letters, kd_max, by = "Site")
cdom_labels <- merge(cdom_letters, cdom_max, by = "Site")
tss_labels <- merge(tss_letters, tss_max, by = "Site")
chla_labels <- merge(chla_letters, chla_max, by = "Site")

```

```{r}

plot_kd <- plot_kd +
  geom_text(data = kd_labels, aes(x = Site, y = Max + 0.2 * Max, label = Letter), size = 3)

plot_CDOM <- plot_CDOM +
  geom_text(data = cdom_labels, aes(x = Site, y = Max + 0.2 * Max, label = Letter), size = 3)

plot_TSS <- plot_TSS +
  geom_text(data = tss_labels, aes(x = Site, y = Max + 0.2 * Max, label = Letter), size = 3)

plot_CHLa <- plot_CHLa +
  geom_text(data = chla_labels, aes(x = Site, y = Max + 0.2 * Max, label = Letter), size = 3)

grid.arrange(plot_kd, plot_CDOM, plot_TSS, plot_CHLa, 
             ncol = 2, nrow = 2, # Ensure 2 columns and 2 rows
             widths = c(1, 1),    # Make the columns the same width
             heights = c(1, 1))

```

```{r}


plot_kd <- plot_kd +
  geom_text(data = kd_labels, aes(x = Site, y = Max + 0.2 * Max, label = Letter), size = 3) +
  theme(
    axis.text.x = element_blank(),
    axis.title.x = element_blank(),
    axis.ticks.x = element_blank()
  )

plot_CDOM <- plot_CDOM +
  geom_text(data = cdom_labels, aes(x = Site, y = Max + 0.2 * Max, label = Letter), size = 3) +
  theme(
    axis.text.x = element_blank(),
    axis.title.x = element_blank(),
    axis.ticks.x = element_blank()
  )

plot_TSS <- plot_TSS +
  geom_text(data = tss_labels, aes(x = Site, y = Max + 0.2 * Max, label = Letter), size = 3) +
  theme(axis.text.x = element_text(size = 8, angle = 45))

plot_CHLa <- plot_CHLa +
  geom_text(data = chla_labels, aes(x = Site, y = Max + 0.2 * Max, label = Letter), size = 3) +
  theme(axis.text.x = element_text(size = 8, angle = 45))

grid.arrange(
  plot_kd, plot_CDOM, plot_TSS, plot_CHLa, 
  ncol = 2, nrow = 2,
  widths = c(1, 1),
  heights = c(1, 1)
)

```


```{r}

# Plot for kd
plot_kd <- ggplot(subset(long_data, Variable == "kd"), aes(x = Site, y = Value)) +
  geom_boxplot(outlier.color = "red", outlier.shape = 16, fill = "lightblue") +
  labs(
    title = NULL,
    x = NULL,
    y = custom_y_labels["kd"]
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.text.y = element_text(size = 8),
    axis.title.y = element_text(size = 10),
    panel.border = element_rect(color = "black", fill = NA, size = 1)  # Add box around chart area
  )

# Plot for CDOM
plot_CDOM <- ggplot(subset(long_data, Variable == "CDOM"), aes(x = Site, y = Value)) +
  geom_boxplot(outlier.color = "red", outlier.shape = 16, fill = "lightblue") +
  labs(
    title = NULL,
    x = NULL,
    y = custom_y_labels["CDOM"]
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_blank(),  # Remove x-axis labels
    axis.text.y = element_text(size = 8),
    axis.title.y = element_text(size = 10),
    panel.border = element_rect(color = "black", fill = NA, size = 1)  # Add box around chart area
  )

# Plot for TSS
plot_TSS <- ggplot(subset(long_data, Variable == "TSS"), aes(x = Site, y = Value)) +
  geom_boxplot(outlier.color = "red", outlier.shape = 16, fill = "lightblue") +
  labs(
    title = NULL,
    x = NULL,
    y = custom_y_labels["TSS"]
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 6),  # Change x-axis text size to 4
    axis.text.y = element_text(size = 8),
    axis.title.y = element_text(size = 10),
    panel.border = element_rect(color = "black", fill = NA, size = 1)  # Add box around chart area
  )

# Plot for CHLa
plot_CHLa <- ggplot(subset(long_data, Variable == "CHLa"), aes(x = Site, y = Value)) +
  geom_boxplot(outlier.color = "red", outlier.shape = 16, fill = "lightblue") +
  labs(
    title = NULL,
    x = NULL,
    y = custom_y_labels["CHLa"]
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 6),  # Change x-axis text size to 4
    axis.text.y = element_text(size = 8),
    axis.title.y = element_text(size = 10),
    panel.border = element_rect(color = "black", fill = NA, size = 1)  # Add box around chart area
  )

# Arrange the plots in a grid layout with equal sizes
grid.arrange(plot_kd, plot_CDOM, plot_TSS, plot_CHLa, 
             ncol = 2, nrow = 2, # Ensure 2 columns and 2 rows
             widths = c(1, 1),    # Make the columns the same width
             heights = c(1, 1))   # Make the rows the same height


```

```{r}

cat("kd ANOVA")

# Perform ANOVA comparing 'kd' across sites
anova_kd <- aov(Value ~ Site, data = long_data %>% filter(Variable == "kd"))

# Run Tukey's HSD post-hoc test
tukey_results <- TukeyHSD(anova_kd)

# Extract the results for the 'Site' factor from the Tukey HSD test
tukey_summary <- tukey_results$Site

# Convert the matrix to a data frame for easier manipulation
tukey_df <- as.data.frame(tukey_summary)

# Add the comparison names as a new column (this will be the rownames)
tukey_df$Comparison <- rownames(tukey_df)

# Filter to keep only the statistically significant comparisons (p-value < 0.05)
significant_comparisons <- tukey_df %>%
  filter(`p adj` < 0.05) %>%
  select(Comparison, `p adj`)  # Select the Comparison and p adj columns

# Print the significant comparisons with p-values
print(significant_comparisons)



```

```{r}

library(multcompView)

cat("kd ANOVA\n")

# Perform ANOVA comparing 'kd' across sites
anova_kd <- aov(Value ~ Site, data = long_data %>% filter(Variable == "kd"))

# Run Tukey's HSD post-hoc test
tukey_results <- TukeyHSD(anova_kd)

# Extract the results for the 'Site' factor
tukey_summary <- tukey_results$Site

# Generate a compact letter display
# multcompLetters takes a named vector of adjusted p-values from Tukey's output
tukey_letters <- multcompLetters(tukey_summary[,"p adj"])

# Combine letters with site names
site_letters <- data.frame(
  Site = names(tukey_letters$Letters),
  Group = tukey_letters$Letters
)

# Print site groupings
print(site_letters)


```


```{r}


cat("CDOM ANOVA\n")

# Perform ANOVA comparing 'CDOM' across sites
anova_cdom <- aov(Value ~ Site, data = long_data %>% filter(Variable == "CDOM"))

# Run Tukey's HSD post-hoc test
tukey_results <- TukeyHSD(anova_cdom)

# Extract the results for the 'Site' factor
tukey_summary <- tukey_results$Site

# Generate compact letter display from adjusted p-values
tukey_letters <- multcompLetters(tukey_summary[,"p adj"])

# Create data frame of site groupings
site_letters <- data.frame(
  Site = names(tukey_letters$Letters),
  Group = tukey_letters$Letters
)

# Print site groupings
print(site_letters)


```


```{r}
# Load required package
library(multcompView)

cat("TSS ANOVA\n")

# Perform ANOVA comparing 'TSS' across sites
anova_tss <- aov(Value ~ Site, data = long_data %>% filter(Variable == "TSS"))

# Run Tukey's HSD post-hoc test
tukey_results <- TukeyHSD(anova_tss)

# Extract the results for the 'Site' factor
tukey_summary <- tukey_results$Site

# Generate compact letter display from adjusted p-values
tukey_letters <- multcompLetters(tukey_summary[,"p adj"])

# Create data frame of site groupings
site_letters <- data.frame(
  Site = names(tukey_letters$Letters),
  Group = tukey_letters$Letters
)

# Print site groupings
print(site_letters)

```


```{r}
# Load required package
library(multcompView)

cat("CHLa ANOVA\n")

# Perform ANOVA comparing 'CHLa' across sites
anova_chla <- aov(Value ~ Site, data = long_data %>% filter(Variable == "CHLa"))

# Run Tukey's HSD post-hoc test
tukey_results <- TukeyHSD(anova_chla)

# Extract the results for the 'Site' factor
tukey_summary <- tukey_results$Site

# Generate compact letter display from adjusted p-values
tukey_letters <- multcompLetters(tukey_summary[,"p adj"])

# Create data frame of site groupings
site_letters <- data.frame(
  Site = names(tukey_letters$Letters),
  Group = tukey_letters$Letters
)

# Print site groupings
print(site_letters)

```

```{r}

swift_creek_data <- fullthesis |> filter(Lake == "Swift Creek Reservoir")

variables <- c("kd", "CDOM", "TSS", "CHLa")

# Create an empty list to store results
tukey_combined <- list()

for (var in variables) {
  aov_result <- aov(as.formula(paste(var, "~ Site")), data = swift_creek_data)

  tukey_results <- TukeyHSD(aov_result)$Site
  
  # Convert to a data frame and add the variable name
  tukey_df <- as.data.frame(tukey_results)
  tukey_df$Comparison <- rownames(tukey_df)
  tukey_df$Variable <- var
  tukey_df$Significant <- tukey_df$`p adj` < 0.05
  
  # Store the results
  tukey_combined[[var]] <- tukey_df
}

# Combine all Tukey results into a single data frame
tukey_combined_df <- do.call(rbind, tukey_combined)

ggplot(tukey_combined_df, aes(x = Comparison, y = diff, ymin = lwr, ymax = upr, color = Significant)) +
  geom_pointrange(position = position_dodge(width = 0.5)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  coord_flip() +
  facet_wrap(~ Variable, scales = "free_y") +
  labs(
    title = "Swift Creek Res: Inter-Site Differences",
    x = "Comparison",
    y = "Difference in Means"
  ) +
  theme_minimal() +
  scale_color_manual(
    values = c("TRUE" = "blue", "FALSE" = "darkgrey"),
    labels = c("TRUE" = "Significant", "FALSE" = "Not Significant")
  ) +
  theme(
    legend.position = "bottom",
    strip.text = element_text(size = 10),  # Adjust facet label size
    axis.text.y = element_text(size = 6)  # Make y-axis text smaller
  )

```

```{r}

sandy_river_data <- fullthesis |> filter(Lake == "Sandy River Reservoir")

variables <- c("kd", "CDOM", "TSS", "CHLa")

# Create an empty list to store results
tukey_combined <- list()

for (var in variables) {
  aov_result <- aov(as.formula(paste(var, "~ Site")), data = sandy_river_data)

  tukey_results <- TukeyHSD(aov_result)$Site
  
  # Convert to a data frame and add the variable name
  tukey_df <- as.data.frame(tukey_results)
  tukey_df$Comparison <- rownames(tukey_df)
  tukey_df$Variable <- var
  tukey_df$Significant <- tukey_df$`p adj` < 0.05
  
  # Store the results
  tukey_combined[[var]] <- tukey_df
}

# Combine all Tukey results into a single data frame
tukey_combined_df <- do.call(rbind, tukey_combined)

ggplot(tukey_combined_df, aes(x = Comparison, y = diff, ymin = lwr, ymax = upr, color = Significant)) +
  geom_pointrange(position = position_dodge(width = 0.5)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  coord_flip() +
  facet_wrap(~ Variable, scales = "free_y") +
  labs(
    title = "Sandy River Reservoir: Inter-Site Differences",
    x = "Comparison",
    y = "Difference in Means"
  ) +
  theme_minimal() +
  scale_color_manual(
    values = c("TRUE" = "blue", "FALSE" = "darkgrey"),
    labels = c("TRUE" = "Significant", "FALSE" = "Not Significant")
  ) +
  theme(
    legend.position = "bottom",
    strip.text = element_text(size = 10),  # Adjust facet label size
    axis.text.y = element_text(size = 6)  # Make y-axis text smaller
  )


```

```{r}

briery_creek_data <- fullthesis |> filter(Lake == "Briery Creek Lake")

variables <- c("kd", "CDOM", "TSS", "CHLa")

# Create an empty list to store results
tukey_combined <- list()

for (var in variables) {
  aov_result <- aov(as.formula(paste(var, "~ Site")), data = briery_creek_data)

  tukey_results <- TukeyHSD(aov_result)$Site
  
  # Convert to a data frame and add the variable name
  tukey_df <- as.data.frame(tukey_results)
  tukey_df$Comparison <- rownames(tukey_df)
  tukey_df$Variable <- var
  tukey_df$Significant <- tukey_df$`p adj` < 0.05
  
  # Store the results
  tukey_combined[[var]] <- tukey_df
}

# Combine all Tukey results into a single data frame
tukey_combined_df <- do.call(rbind, tukey_combined)

ggplot(tukey_combined_df, aes(x = Comparison, y = diff, ymin = lwr, ymax = upr, color = Significant)) +
  geom_pointrange(position = position_dodge(width = 0.5)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  coord_flip() +
  facet_wrap(~ Variable, scales = "free_y") +
  labs(
    title = "Briery Creek Lake: Inter-Site Differences",
    x = "Comparison",
    y = "Difference in Means"
  ) +
  theme_minimal() +
  scale_color_manual(
    values = c("TRUE" = "blue", "FALSE" = "darkgrey"),
    labels = c("TRUE" = "Significant", "FALSE" = "Not Significant")
  ) +
  theme(
    legend.position = "bottom",
    strip.text = element_text(size = 10),  # Adjust facet label size
    axis.text.y = element_text(size = 6)  # Make y-axis text smaller
  )

```

## Station Average Data

```{r}

# Calculate means for each Site
mean_values <- fullthesis |>
  group_by(Site) |>
  summarise(
    mean_kd = mean(kd, na.rm = TRUE),
    mean_CDOM = mean(CDOM, na.rm = TRUE),
    mean_CHLa = mean(CHLa, na.rm = TRUE),
    mean_TSS = mean(TSS, na.rm = TRUE)
  )

# View the result
print(mean_values)

```

```{r}

meanthesis <- read_csv("https://docs.google.com/spreadsheets/d/e/2PACX-1vSzc4O_yfQyjR6m0xebm0MWcQ58v-aMF1cq1zDVMJ9Qs-tGrgf94j21Ood2xGH-f5hw-gC8CqpjenBO/pub?gid=0&single=true&output=csv")

```

```{r}

# Function to extract regression statistics (equation, R-squared, p-value, SE)
get_regression_stats <- function(x, y) {
  model <- lm(y ~ x)
  eq <- paste("y = ", round(coef(model)[2], 2), "x + ", round(coef(model)[1], 2), sep = "")
  rsq <- paste("R² = ", round(summary(model)$r.squared, 3), sep = "")
  pval <- paste("p = ", round(summary(model)$coefficients[2, 4], 3), sep = "")
  se <- paste("SE = ", round(summary(model)$coefficients[2, 2], 3), sep = "")  # Extract SE
  return(list(eq = eq, rsq = rsq, pval = pval, se = se))
}

# p1 - Regression: kd (m⁻¹) vs TSS (mg/L)
reg_stats_p1 <- get_regression_stats(meanthesis$`TSS (mg/L)`, meanthesis$`kd (m-1)`)
p1 <- ggplot(meanthesis, aes(x = `TSS (mg/L)`, y = `kd (m-1)`)) +
  geom_point(color = "gray70") +  # Use a darker gray for points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Black regression line
  labs(title = "kd vs TSS", x = "TSS (mg L⁻¹)", y = "kd (m⁻¹)") +
  geom_text(x = max(meanthesis$`TSS (mg/L)`), y = max(meanthesis$`kd (m-1)`), 
            label = paste(reg_stats_p1$eq, "\n", reg_stats_p1$rsq, "\n", reg_stats_p1$pval, "\n", reg_stats_p1$se), 
            hjust = 1, vjust = 2, size = 2, color = "black") +  # Text color black
  theme_minimal() +
  theme(
    plot.title = element_text(size = 7, color = "black"),  # Chart title black
     axis.line = element_line(colour = "black", size = 0.5),  # Add black axis lines
    axis.title.x = element_text(size = 8, color = "black"),  # X-axis title black
    axis.title.y = element_text(size = 8, color = "black")   # Y-axis title black
  )

# p2 - Regression: Residual kd after TSS vs CDOM a440 (corr)
reg_stats_p2 <- get_regression_stats(meanthesis$`CDOM a440 (corr)`, meanthesis$`Residual kd after TSS`)
p2 <- ggplot(meanthesis, aes(x = `CDOM a440 (corr)`, y = `Residual kd after TSS`)) +
  geom_point(color = "gray70") +  # Use a lighter gray for points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Black regression line
  labs(title = "Residual kd vs CDOM", x = "CDOM (m⁻¹)", y = "Residual kd after TSS (m⁻¹)") +
  geom_text(x = max(meanthesis$`CDOM a440 (corr)`), y = max(meanthesis$`Residual kd after TSS`), 
            label = paste(reg_stats_p2$eq, "\n", reg_stats_p2$rsq, "\n", reg_stats_p2$pval, "\n", reg_stats_p2$se), 
            hjust = 1, vjust = 2, size = 2, color = "black") +  # Text color black
  theme_minimal() +
  theme(
    plot.title = element_text(size = 7, color = "black"),  # Chart title black
     axis.line = element_line(colour = "black", size = 0.5),  # Add black axis lines
    axis.title.x = element_text(size = 8, color = "black"),  # X-axis title black
    axis.title.y = element_text(size = 8, color = "black")   # Y-axis title black
  )

# p3 - Regression: kd vs CHLa (ug/L)
reg_stats_p3 <- get_regression_stats(meanthesis$`CHLa (ug/L)`, meanthesis$`kd (m-1)`)
p3 <- ggplot(meanthesis, aes(x = `CHLa (ug/L)`, y = `kd (m-1)`)) +
  geom_point(color = "gray70") +  # Use an even lighter gray for points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Black regression line
  labs(title = "kd vs CHLa", x = "CHLa (µg L⁻¹)", y = "kd (m⁻¹)") +
  geom_text(x = max(meanthesis$`CHLa (ug/L)`), y = max(meanthesis$`kd (m-1)`), 
            label = paste(reg_stats_p3$eq, "\n", reg_stats_p3$rsq, "\n", reg_stats_p3$pval, "\n", reg_stats_p3$se), 
            hjust = 1, vjust = 3, size = 2, color = "black") +  # Text color black
  theme_minimal() +
  theme(
    plot.title = element_text(size = 7, color = "black"),  # Chart title black
     axis.line = element_line(colour = "black", size = 0.5),  # Add black axis lines
    axis.title.x = element_text(size = 8, color = "black"),  # X-axis title black
    axis.title.y = element_text(size = 8, color = "black")   # Y-axis title black
  )

# Display plots in a grid
grid.arrange(p1, p2, p3, ncol = 2)



```


```{r}

# Function to create diagnostic plots for each model
create_diagnostic_plots <- function(model) {
  par(mfrow = c(2, 2))  # Arrange the plots in a 2x2 grid

  # Residuals vs Fitted plot
  plot(model, which = 1, main = "Residuals vs Fitted")

  # Normal Q-Q plot
  plot(model, which = 2, main = "Normal Q-Q")

  # Scale-Location plot
  plot(model, which = 3, main = "Scale-Location")

  # Residuals vs Leverage plot
  plot(model, which = 5, main = "Residuals vs Leverage")
}

print("Residual Plots for Regression: kd vs TSS")

# p1 Model: Regression: kd (m⁻¹) vs TSS (mg/L)
model_p1 <- lm(`kd (m-1)` ~ `TSS (mg/L)`, data = meanthesis)
create_diagnostic_plots(model_p1)

print("Residual Plots for Regression: Residual kd vs CDOM")

# p2 Model: Regression: Residual kd after TSS vs CDOM a440 (corr)
model_p2 <- lm(`Residual kd after TSS` ~ `CDOM a440 (corr)`, data = meanthesis)
create_diagnostic_plots(model_p2)

print("Residual Plots for Regression: Residual kd vs CHLa")

# p3 Model: Regression: Residual kd after TSS vs CHLa (ug/L)
model_p3 <- lm(`Residual kd after TSS` ~ `CHLa (ug/L)`, data = meanthesis)
create_diagnostic_plots(model_p3)


```


### Multiple Linear Regression

```{r}

response <- "`kd (m-1)`"  # Use backticks around the column name with special characters
predictors <- c("`TSS (mg/L)`", "`CDOM a440 (corr)`", "`CHLa (ug/L)`")  

# Generate all combinations of predictors
all_combinations <- unlist(
  lapply(0:length(predictors), function(x) combn(predictors, x, simplify = FALSE)), 
  recursive = FALSE
)

# Fit models for each combination and calculate AIC
model_results <- lapply(all_combinations, function(predictor_set) {
  # Create the formula for the current combination of predictors
  formula <- as.formula(paste(response, "~", ifelse(length(predictor_set) == 0, "1", paste(predictor_set, collapse = " + "))))
  
  # Fit the linear model
  model <- lm(formula, data = meanthesis)
  
  # Return the model, predictors, and AIC
  list(
    predictors = predictor_set,
    model = model,
    AIC = AIC(model)
  )
})

# Convert results to a dataframe for easier analysis
results_df <- do.call(rbind, lapply(model_results, function(x) {
  data.frame(
    Predictors = paste(x$predictors, collapse = " + "),
    AIC = x$AIC
  )
}))

# Find the model with the lowest AIC
min_AIC <- min(results_df$AIC)

# Calculate the delta AIC for each model (difference from the minimum AIC)
results_df <- results_df %>%
  mutate(Delta_AIC = AIC - min_AIC) %>%
  arrange(Delta_AIC)  # Sort by delta AIC

# Print the results with Delta AIC
print(results_df)


```

The best model for predicting kd (m-1) is Model 1, which includes the predictors TSS (mg/L) and CDOM a440 (corr). This model has the lowest AIC and provides the best fit to the data. Model 2, which adds CHLa (ug/L) to the combination of TSS (mg/L) and CDOM a440 (corr), has a slightly higher AIC but still performs quite well, this indicates that the addition of CHLa as a predictor adds little to no predictive power to the model. On the other hand, models with only one predictor, such as Model 4 (TSS (mg/L)), Model 5 (CDOM a440 (corr)), and Model 7 (CHLa (ug/L)), perform significantly worse, with much higher AIC values. The intercept-only model. Overall, the results suggest that TSS (mg/L) and CDOM a440 (corr) are the most important predictors for kd (m-1), and adding CHLa (ug/L) slightly reduces the model's performance.

```{r}
meanthesis_long <- meanthesis %>%
  gather(key = "Source", value = "Percentage", `% kd from TSS`, `% kd from CDOM`) %>%
  mutate(Percentage = as.numeric(gsub("%", "", Percentage)))  # Remove '%' and convert to numeric

# Manually recoding the 'Site' variable in the meanthesis_long dataset
meanthesis_long <- meanthesis_long %>%
  mutate(
    Site = dplyr::recode(Site, 
                         "2-BRI010.78" = "BRI_1",
                         "2-BRI013.12" = "BRI_2",
                         "5ANTW127.14" = "Barfoot",
                         "2-CHK026.94" = "Chick",
                         "Harrison Near Dam" = "Harrison",
                         "2-SDY004.27" = "SDY_1",
                         "2-SDY005.85" = "SDY_2",
                         "2-MBN000.96" = "SDY_3",
                         "2-SFT031.08" = "SFT_1",
                         "2-DYC000.19" = "SFT_2",
                         "2-SFT033.42" = "SFT_3",
                         "2-SFT034.38" = "SFT_4",
                         "Lake Anna Dam Surface" = "ANNA")
  )

site_order <- c( "Harrison", "Chick", "BRI_1", "BRI_2", "SDY_1", "SDY_2", "SDY_3", "SFT_1", "SFT_2", "SFT_3", "SFT_4", "Barfoot", "ANNA")

# Update the long_data to apply the specific Site order
meanthesis_long <- meanthesis_long %>%
  mutate(Site = factor(Site, levels = site_order)) 

meanthesis_long <- meanthesis_long %>%
  filter(Site != "ANNA")

# Create the stacked bar plot with customized y-axis
ggplot(meanthesis_long, aes(x = Site, y = Percentage, fill = Source)) +
  geom_bar(stat = "identity") +  # Use "identity" to map the y-values directly
  labs(title = " ",
       x = "Site",
       y = "% kd",
       fill = "Source") +
  scale_fill_manual(values = c("% kd from TSS" = "blue", "% kd from CDOM" = "red")) +  # Custom colors
  scale_y_continuous(
    breaks = seq(0, 100, by = 25),  # Set y-axis breaks at 0, 25, 50, 75, and 100 (numeric)
    labels = scales::percent_format(scale = 1)  # Format y-axis labels as percentages
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 10, color = "black"),
     axis.line = element_line(colour = "black", size = 0.5), # Title size and color
    axis.title.x = element_text(size = 10, color = "black"),  # X-axis title size and color
    axis.title.y = element_text(size = 10, color = "black"),  # Y-axis title size and color
    axis.text.x = element_text(angle = 45, hjust = 1)  # Rotate x-axis labels for readability
  )
```

## Lake Anna

```{r}

annaurl <- "https://docs.google.com/spreadsheets/d/e/2PACX-1vSzc4O_yfQyjR6m0xebm0MWcQ58v-aMF1cq1zDVMJ9Qs-tGrgf94j21Ood2xGH-f5hw-gC8CqpjenBO/pub?gid=853297443&single=true&output=csv"

annadata <- read_csv(annaurl)

```

```{r}

# Ensure the Date column is in Date format
annadata$Date <- as.Date(annadata$Date, format = "%m/%d/%Y")

```

```{r}

ggplot(annadata) +
  # Points and line for kd
  geom_point(aes(x = Date, y = kd), color = "black", size = 3) +  
  geom_line(aes(x = Date, y = kd, group = 1), color = "black") +  # Line connecting kd points
  
  labs(x = "Date", y = "Kd (m⁻¹)") +  # Update title and y-axis label
  
  scale_x_date(
    breaks = "1 month",
    labels = scales::date_format("%b %Y")
  ) +
  
  theme_minimal() +
  theme(
    legend.position = "none",  # No legend needed for single variable
    axis.line = element_line(colour = "black", size = 0.5),
    axis.text.x = element_text(size = 10, angle = 90, hjust = 1, color = "black"),
    axis.text.y = element_text(size = 9)
  )


```


```{r}
ggplot(annadata) +
  # Points and lines for Surface_TSS
  geom_point(aes(x = Date, y = Surface_TSS, color = "Surface"), size = 3) +  
  geom_line(aes(x = Date, y = Surface_TSS, color = "Surface", group = 1)) +  # Add group aesthetic
  
  # Points and lines for Photic_TSS
  geom_point(aes(x = Date, y = Photic_TSS, color = "Photic Zone Average"), size = 3) +  
  geom_line(aes(x = Date, y = Photic_TSS, color = "Photic Zone Average", group = 1)) +  # Add group aesthetic
  
  # Points and lines for Bottom_TSS
  geom_point(aes(x = Date, y = Bottom_TSS, color = "Bottom"), size = 3) +  
  geom_line(aes(x = Date, y = Bottom_TSS, color = "Bottom", group = 1)) +  # Add group aesthetic
  
  labs(title = " ", x = " ", y = "TSS (mg L⁻¹") +
  scale_color_manual(values = c("Surface" = "black", "Photic Zone Average" = "blue", "Bottom" = "red")) +  # Custom colors
  
  scale_x_date(
    breaks = "1 month",  # Set tickmarks every month
    labels = scales::date_format("%b %Y")  # Format labels as Month Year (e.g., Jan 2020)
  ) +
  
  theme_minimal() +  # Minimal theme
  theme(
    legend.title = element_blank(),
    legend.position = "top",  
    axis.line = element_line(colour = "black", size = 0.5),  # Add black axis lines
    axis.text.x = element_blank(),
    axis.text.y = element_text(size = 9))



```

```{r}
ggplot(annadata) +
  # Points and lines for Surface_CDOM
  geom_point(aes(x = Date, y = Surface_CDOM, color = "Surface"), size = 3) +  
  geom_line(aes(x = Date, y = Surface_CDOM, color = "Surface", group = 1)) +  # Add group aesthetic
  
  # Points and lines for Photic_CDOM
  geom_point(aes(x = Date, y = Photic_CDOM, color = "Photic Zone Average"), size = 3) +  
  geom_line(aes(x = Date, y = Photic_CDOM, color = "Photic Zone Average", group = 1)) +  # Add group aesthetic
  
  # Points and lines for Bottom_CDOM
  geom_point(aes(x = Date, y = Bottom_CDOM, color = "Bottom"), size = 3) +  
  geom_line(aes(x = Date, y = Bottom_CDOM, color = "Bottom", group = 1)) +  # Add group aesthetic
  
  labs(title = " ", x = " ", y = "CDOM (m⁻¹)") +
  scale_color_manual(values = c("Surface" = "black", "Photic Zone Average" = "blue", "Bottom" = "red")) +  # Custom colors
  
  scale_x_date(
    breaks = "1 month",  # Set tickmarks every month
    labels = scales::date_format("%b %Y")  # Format labels as Month Year (e.g., Jan 2020)
  ) +
  
  scale_y_continuous(
    limits = c(0, 2)  # Set y-axis limits from 0 to 2
  ) +
  
    theme_minimal() +  # Minimal theme
  theme(
    legend.title = element_blank(),
    legend.position = "top",  
    axis.line = element_line(colour = "black", size = 0.5),  # Add black axis lines
    axis.text.x = element_blank(),
    axis.text.y = element_text(size = 9))

```

```{r}

ggplot(annadata) +
  # Points and lines for Surface_CHLa
  geom_point(aes(x = Date, y = Surface_CHLa, color = "Surface"), size = 3) +  
  geom_line(aes(x = Date, y = Surface_CHLa, color = "Surface", group = 1)) +  # Add group aesthetic
  
  # Points and lines for Photic_CHLa
  geom_point(aes(x = Date, y = Photic_CHLa, color = "Photic Zone Average"), size = 3) +  
  geom_line(aes(x = Date, y = Photic_CHLa, color = "Photic Zone Average", group = 1)) +  # Add group aesthetic
  
  labs(title = " ", x = " ", y = "CHLa (µg L⁻¹)") +
  scale_color_manual(values = c("Surface" = "black", "Photic Zone Average" = "blue")) +  # Custom colors
  
  scale_x_date(
    breaks = "1 month",  # Set tickmarks every month
    labels = scales::date_format("%b %Y")  # Format labels as Month Year (e.g., Jan 2020)
  ) +
  
   theme_minimal() +  # Minimal theme
  theme(
    legend.title = element_blank(),
    legend.position = "top",  
    axis.line = element_line(colour = "black", size = 0.5),  # Add black axis lines
    axis.text.x = element_blank(),
    axis.text.y = element_text(size = 9))

```

```{r}

# Function to extract regression statistics (equation, R-squared, p-value, and residual SE)
get_regression_stats_se <- function(x, y) {
  # Remove NA values from both x and y
  data <- na.omit(data.frame(x, y))
  
  # Fit the linear regression model
  model <- lm(y ~ x, data = data)
  
  # Extract coefficients
  coef_values <- coef(model)
  
  # Create the equation text
  eq <- paste("y = ", round(coef_values[2], 2), "x + ", round(coef_values[1], 2), sep = "")
  
  # Calculate R-squared and p-value
  rsq <- paste("R² = ", round(summary(model)$r.squared, 3), sep = "")
  pval <- paste("p = ", round(summary(model)$coefficients[2, 4], 3), sep = "")
  
  # Get residual standard error (SE of the model)
  residual_se <- paste("SE = ", round(summary(model)$sigma, 2), sep = "")
  
  return(list(eq = eq, rsq = rsq, pval = pval, residual_se = residual_se))
}

# p1 - Regression: Photic_TSS vs kd
reg_stats_p1 <- get_regression_stats_se(annadata$Photic_TSS, annadata$kd)
p1 <- ggplot(annadata, aes(x = Photic_TSS, y = kd)) +
  geom_point(color = "gray70") +  # Use a darker gray for points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Black regression line
  labs(title = "Lake Anna: Photic Zone TSS vs kd", x = "TSS (mg L⁻¹)", y = "kd (m⁻¹)") +
  geom_text(x = max(annadata$Photic_TSS, na.rm = TRUE), y = max(annadata$kd, na.rm = TRUE), 
            label = paste(reg_stats_p1$eq, "\n", reg_stats_p1$rsq, "\n", reg_stats_p1$pval, "\n", reg_stats_p1$residual_se), 
            hjust = 1, vjust = 2, size = 2, color = "black") +  # Text color black
  theme_minimal() +
  theme(
    plot.title = element_text(size = 7, color = "black"),  # Chart title black
     axis.line = element_line(colour = "black", size = 0.5),  # Add black axis lines
    axis.title.x = element_text(size = 8, color = "black"),  # X-axis title black
    axis.title.y = element_text(size = 8, color = "black")   # Y-axis title black
  )

# p2 - Regression: Photic_CDOM vs kd
reg_stats_p2 <- get_regression_stats_se(annadata$Photic_CDOM, annadata$kd)
p2 <- ggplot(annadata, aes(x = Photic_CDOM, y = kd)) +
  geom_point(color = "gray70") +  # Use a lighter gray for points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Black regression line
  labs(title = "Lake Anna: Photic Zone CDOM vs kd", x = "CDOM (m⁻¹)", y = "kd (m⁻¹)") +
  geom_text(x = max(annadata$Photic_CDOM, na.rm = TRUE), y = max(annadata$kd, na.rm = TRUE), 
            label = paste(reg_stats_p2$eq, "\n", reg_stats_p2$rsq, "\n", reg_stats_p2$pval, "\n", reg_stats_p2$residual_se), 
            hjust = 1, vjust = 1, size = 2, color = "black") +  # Text color black
  theme_minimal() +
  theme(
    plot.title = element_text(size = 7, color = "black"),  # Chart title black
     axis.line = element_line(colour = "black", size = 0.5),  # Add black axis lines
    axis.title.x = element_text(size = 8, color = "black"),  # X-axis title black
    axis.title.y = element_text(size = 8, color = "black")   # Y-axis title black
  )

# p3 - Regression: Photic_CHLa vs kd
reg_stats_p3 <- get_regression_stats_se(annadata$Photic_CHLa, annadata$kd)
p3 <- ggplot(annadata, aes(x = Photic_CHLa, y = kd)) +
  geom_point(color = "gray70") +  # Use an even lighter gray for points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Black regression line
  labs(title = "Lake Anna: Photic Zone CHLa vs kd", x = "CHLa (µg L⁻¹))", y = "kd (m⁻¹)") +
  geom_text(x = max(annadata$Photic_CHLa, na.rm = TRUE), y = max(annadata$kd, na.rm = TRUE), 
            label = paste(reg_stats_p3$eq, "\n", reg_stats_p3$rsq, "\n", reg_stats_p3$pval, "\n", reg_stats_p3$residual_se), 
            hjust = 1, vjust = 2, size = 2, color = "black") +  # Text color black
  theme_minimal() +
  theme(
    plot.title = element_text(size = 7, color = "black"),  # Chart title black
     axis.line = element_line(colour = "black", size = 0.5),  # Add black axis lines
    axis.title.x = element_text(size = 8, color = "black"),  # X-axis title black
    axis.title.y = element_text(size = 8, color = "black")   # Y-axis title black
  )

# Arrange the plots using gridExtra
grid.arrange(p1, p2, p3, ncol = 2)


```

```{r}

# Function to create diagnostic plots for a linear model
create_diagnostic_plots <- function(model, title) {
  par(mfrow = c(2, 2), mar = c(4, 4, 2, 1))
  
  # Residuals vs Fitted plot
  plot(model, which = 1)
  
  # Normal Q-Q plot
  plot(model, which = 2)
  
  # Scale-Location plot
  plot(model, which = 3)
  
  # Residuals vs Leverage plot
  plot(model, which = 5)
  
  par(mfrow = c(1, 1))  # Reset the plotting layout to single panel
}

# Create the linear regression models for p1, p2, p3
model_p1 <- lm(kd ~ Photic_TSS, data = annadata)
model_p2 <- lm(kd ~ Photic_CDOM, data = annadata)
model_p3 <- lm(kd ~ Photic_CHLa, data = annadata)

# Create diagnostic plots for each of the models
print("Lake Anna: Photic Zone kd vs TSS")

create_diagnostic_plots(model_p1)

print("Lake Anna: Photic Zone kd vs CDOM")

create_diagnostic_plots(model_p2)

print("Lake Anna: Photic Zone kd vs CHLa")

create_diagnostic_plots(model_p3)


```

### Lake Anna Multiple Linear Regression

```{r}

# Define the full dataset and predictors
response <- "kd"
predictors <- c("Photic_TSS", "Photic_CDOM", "Photic_CHLa")  # Adjust predictors based on your dataset

# Generate all combinations of predictors
all_combinations <- unlist(
  lapply(0:length(predictors), function(x) combn(predictors, x, simplify = FALSE)), 
  recursive = FALSE
)

# Fit models for each combination and calculate AIC
model_results <- lapply(all_combinations, function(predictor_set) {
  # Create the formula for the current combination of predictors
  formula <- as.formula(paste(response, "~", ifelse(length(predictor_set) == 0, "1", paste(predictor_set, collapse = " + "))))
  
  # Fit the linear model
  model <- lm(formula, data = annadata)
  
  # Return the model, predictors, and AIC
  list(
    predictors = predictor_set,
    model = model,
    AIC = AIC(model)
  )
})

# Convert results to a dataframe for easier analysis
results_df <- do.call(rbind, lapply(model_results, function(x) {
  data.frame(
    Predictors = paste(x$predictors, collapse = " + "),
    AIC = x$AIC
  )
}))

# Find the model with the lowest AIC
min_AIC <- min(results_df$AIC)

# Calculate the delta AIC for each model (difference from the minimum AIC)
Annaresults_df <- results_df %>%
  mutate(Delta_AIC = AIC - min_AIC) %>%
  arrange(Delta_AIC)  # Sort by delta AIC

# Print the results with Delta AIC
print(Annaresults_df)

```

The results of the AIC-based model comparison indicate that Photic_CHLa is the most effective predictor for kd, as the model using only Photic_CHLa (Model 1) has the lowest AIC value. This model outperforms all other combinations of predictors, suggesting that Photic_CHLa alone explains the variation in kd more effectively than any other model. The inclusion of Photic_TSS alongside Photic_CHLa (Model 2) results in only a marginal increase in AIC, indicating that adding Photic_TSS does not significantly improve the model's predictive ability. Models using Photic_TSS or Photic_CDOM alone, such as Models 3 and 8, perform considerably worse, with higher AIC values and larger delta AIC values, highlighting that these predictors are less effective in explaining kd by themselves. Furthermore, models that combine Photic_TSS with Photic_CDOM or all three predictors (Photic_TSS, Photic_CDOM, and Photic_CHLa) result in higher AIC values, indicating that adding these predictors does not enhance model performance. Overall, the findings suggest that Photic_CHLa is the most crucial factor in predicting kd, while other variables like Photic_TSS and Photic_CDOM do not contribute meaningfully to the model.

## Polynomial Regressions

```{r}

# Function to extract regression statistics (equation, R-squared, p-value, and residual SE) for polynomial regression
get_regression_stats_poly_se <- function(x, y, degree = 2) {
  # Remove NA values from both x and y
  data <- na.omit(data.frame(x, y))
  
  # Perform polynomial regression (degree=2 for quadratic, degree=3 for cubic, etc.)
  model <- lm(y ~ poly(x, degree), data = data)
  
  # Extract coefficients
  coef_values <- coef(model)
  
  # Create the equation text for polynomial regression (for degree 2, we have x² term)
  eq <- paste("y = ", round(coef_values[2], 2), "x + ", round(coef_values[3], 2), "x² + ", round(coef_values[1], 2), sep = "")
  
  # Calculate R-squared and p-value for the model
  rsq <- paste("R² = ", round(summary(model)$r.squared, 3), sep = "")
  pval <- paste("p = ", round(summary(model)$coefficients[2, 4], 3), sep = "")
  
  # Get residual standard error (SE of the model)
  residual_se <- paste("SE = ", round(summary(model)$sigma, 2), sep = "")
  
  return(list(eq = eq, rsq = rsq, pval = pval, residual_se = residual_se))
}

# p1 - Polynomial Regression: Photic_TSS vs kd
reg_stats_p1_poly <- get_regression_stats_poly_se(annadata$Photic_TSS, annadata$kd)
p1 <- ggplot(annadata, aes(x = Photic_TSS, y = kd)) +
  geom_point(color = "gray70") +  # Use a darker gray for points
  geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "black", se = FALSE) +  # Polynomial regression line
  labs(title = "Lake Anna: Photic Zone TSS vs kd", x = "TSS (mg L⁻¹)", y = "kd (m⁻¹)") +
  geom_text(x = max(annadata$Photic_TSS, na.rm = TRUE), y = max(annadata$kd, na.rm = TRUE), 
            label = paste(reg_stats_p1_poly$eq, "\n", reg_stats_p1_poly$rsq, "\n", reg_stats_p1_poly$pval, "\n", reg_stats_p1_poly$residual_se), 
            hjust = 1, vjust = 2, size = 2, color = "black") +  # Text color black
  theme_minimal() +
  theme(
    plot.title = element_text(size = 7, color = "black"),  # Chart title black
     axis.line = element_line(colour = "black", size = 0.5),  # Add black axis lines
    axis.title.x = element_text(size = 6, color = "black"),  # X-axis title black
    axis.title.y = element_text(size = 6, color = "black")   # Y-axis title black
  )

# p2 - Polynomial Regression: Photic_CDOM vs kd
reg_stats_p2_poly <- get_regression_stats_poly_se(annadata$Photic_CDOM, annadata$kd)
p2 <- ggplot(annadata, aes(x = Photic_CDOM, y = kd)) +
  geom_point(color = "gray70") +  # Use a lighter gray for points
  geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "black", se = FALSE) +  # Polynomial regression line
  labs(title = "Lake Anna: Photic Zone CDOM vs kd", x = "CDOM (m⁻¹)", y = "kd (m⁻¹)") +
  geom_text(x = max(annadata$Photic_CDOM, na.rm = TRUE), y = max(annadata$kd, na.rm = TRUE), 
            label = paste(reg_stats_p2_poly$eq, "\n", reg_stats_p2_poly$rsq, "\n", reg_stats_p2_poly$pval, "\n", reg_stats_p2_poly$residual_se), 
            hjust = 1, vjust = 1, size = 2, color = "black") +  # Text color black
  theme_minimal() +
  theme(
    plot.title = element_text(size = 7, color = "black"),  # Chart title black
     axis.line = element_line(colour = "black", size = 0.5),  # Add black axis lines
    axis.title.x = element_text(size = 6, color = "black"),  # X-axis title black
    axis.title.y = element_text(size = 6, color = "black")   # Y-axis title black
  )

# p3 - Polynomial Regression: Photic_CHLa vs kd
reg_stats_p3_poly <- get_regression_stats_poly_se(annadata$Photic_CHLa, annadata$kd)
p3 <- ggplot(annadata, aes(x = Photic_CHLa, y = kd)) +
  geom_point(color = "gray70") +  # Use an even lighter gray for points
  geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "black", se = FALSE) +  # Polynomial regression line
  labs(title = "Lake Anna: Photic Zone CHLa vs kd", x = "CHLa (µg L⁻¹)", y = "kd (m⁻¹)") +
  geom_text(x = max(annadata$Photic_CHLa, na.rm = TRUE), y = max(annadata$kd, na.rm = TRUE), 
            label = paste(reg_stats_p3_poly$eq, "\n", reg_stats_p3_poly$rsq, "\n", reg_stats_p3_poly$pval, "\n", reg_stats_p3_poly$residual_se), 
            hjust = 1, vjust = 2, size = 2, color = "black") +  # Text color black
  theme_minimal() +
  theme(
    plot.title = element_text(size = 7, color = "black"),  # Chart title black
     axis.line = element_line(colour = "black", size = 0.5),  # Add black axis lines
    axis.title.x = element_text(size = 6, color = "black"),  # X-axis title black
    axis.title.y = element_text(size = 6, color = "black")   # Y-axis title black
  )

# Arrange the plots using gridExtra
grid.arrange(p1, p2, p3, ncol = 2)

```

```{r}
# Function to create diagnostic plots for a polynomial regression model
create_diagnostic_plots_poly <- function(x, y, degree = 2) {
  # Remove NA values from both x and y
  data <- na.omit(data.frame(x, y))
  
  # Fit the polynomial regression model
  model <- lm(y ~ poly(x, degree), data = data)
  
  # Print the model summary (optional)
  print(summary(model))
  
  # Set up the plotting layout (2x2 grid)
  par(mfrow = c(2, 2), mar = c(4, 4, 2, 1))
  
  # Residuals vs Fitted plot
  plot(model, which = 1)
  
  # Normal Q-Q plot
  plot(model, which = 2)
  
  # Scale-Location plot
  plot(model, which = 3)
  
  # Residuals vs Leverage plot
  plot(model, which = 5)
  
  # Reset the plotting layout to a single panel
  par(mfrow = c(1, 1))
}

# p1 - Polynomial Regression: Photic_TSS vs kd
print("Lake Anna: Photic Zone TSS vs kd (Polynomial)")
create_diagnostic_plots_poly(annadata$Photic_TSS, annadata$kd, degree = 2)

# p2 - Polynomial Regression: Photic_CDOM vs kd
print("Lake Anna: Photic Zone CDOM vs kd (Polynomial)")
create_diagnostic_plots_poly(annadata$Photic_CDOM, annadata$kd, degree = 2)

# p3 - Polynomial Regression: Photic_CHLa vs kd
print("Lake Anna: Photic Zone CHLa vs kd (Polynomial)")
create_diagnostic_plots_poly(annadata$Photic_CHLa, annadata$kd, degree = 2)

```

### Lake Anna Multiple Polynomial Regression

```{r}
# Define the full dataset and predictors
response <- "kd"
predictors <- c("Photic_TSS", "Photic_CDOM", "Photic_CHLa")  # Adjust predictors based on your dataset

# Generate all combinations of predictors
all_combinations <- unlist(
  lapply(0:length(predictors), function(x) combn(predictors, x, simplify = FALSE)), 
  recursive = FALSE
)

# Fit models for each combination and calculate AIC
model_results <- lapply(all_combinations, function(predictor_set) {
  # Create the formula for the current combination of predictors
  formula <- as.formula(paste(response, "~", ifelse(length(predictor_set) == 0, "1", paste(predictor_set, collapse = " + "))))
  
  # Fit the linear model
  model <- lm(formula, data = annadata)
  
  # Return the model, predictors, and AIC
  list(
    predictors = predictor_set,
    model = model,
    AIC = AIC(model)
  )
})

# Convert results to a dataframe for easier analysis
results_df <- do.call(rbind, lapply(model_results, function(x) {
  data.frame(
    Predictors = paste(x$predictors, collapse = " + "),
    AIC = x$AIC
  )
}))

# Find the model with the lowest AIC
min_AIC <- min(results_df$AIC)

# Calculate the delta AIC for each model (difference from the minimum AIC)
polyAnnaresults_df <- results_df %>%
  mutate(Delta_AIC = AIC - min_AIC) %>%
  arrange(Delta_AIC)  # Sort by delta AIC

# Print the results with Delta AIC
print(polyAnnaresults_df)


```

Based on the AIC values and their corresponding Delta AIC values, the best model for explaining the response variable kd is the one that includes only the predictor Photic_CHLa, which has the lowest AIC of -35.00866 and a Delta AIC of 0. This model provides the best fit to the data without overfitting. When additional predictors such as Photic_TSS and Photic_CDOM are added, the AIC values increase, indicating that these models perform worse. Notably, the model using all three predictors (Photic_TSS + Photic_CDOM + Photic_CHLa) has an AIC of -29.88434, which is higher than the single predictor model, suggesting that the addition of extra predictors does not improve the model’s performance. This implies that some of the predictors, such as Photic_TSS and Photic_CDOM, may not provide significant explanatory power for kd. The worst-performing models are those that include combinations of Photic_TSS and Photic_CDOM, which have higher AIC values and larger Delta AIC values, further confirming that these predictors do not contribute much to explaining the variation in the response variable. In conclusion, Photic_CHLa alone appears to be the most effective predictor of kd in this dataset.

## Secchi Depth


```{r}
# Function to extract regression statistics (equation, R-squared, p-value, SE)
get_regression_stats <- function(x, y) {
  model <- lm(y ~ x)
  eq <- paste("y = ", round(coef(model)[2], 2), "x + ", round(coef(model)[1], 2), sep = "")
  rsq <- paste("R² = ", round(summary(model)$r.squared, 3), sep = "")
  pval <- paste("p = ", round(summary(model)$coefficients[2, 4], 3), sep = "")
  se <- paste("SE = ", round(summary(model)$coefficients[2, 2], 3), sep = "")
  return(list(eq = eq, rsq = rsq, pval = pval, se = se))
}

# p1 - Regression: Secchi (m) vs TSS (mg/L)
reg_stats_p1 <- get_regression_stats(meanthesis$`TSS (mg/L)`, meanthesis$`Secchi (m)`)
p1 <- ggplot(meanthesis, aes(x = `TSS (mg/L)`, y = `Secchi (m)`)) +
  geom_point(color = "gray70") +
  geom_smooth(method = "lm", color = "black", se = FALSE) +
  labs(title = "Secchi vs TSS", x = "TSS (mg L⁻¹)", y = "Secchi (m)") +
  geom_text(x = max(meanthesis$`TSS (mg/L)`, na.rm = TRUE), 
            y = max(meanthesis$`Secchi (m)`, na.rm = TRUE), 
            label = paste(reg_stats_p1$eq, "\n", reg_stats_p1$rsq, "\n", reg_stats_p1$pval, "\n", reg_stats_p1$se), 
            hjust = 1, vjust = 2, size = 2, color = "black") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 7, color = "black"),
    axis.line = element_line(colour = "black", size = 0.5),
    axis.title.x = element_text(size = 8, color = "black"),
    axis.title.y = element_text(size = 8, color = "black")
  )

# Create a new column: residual_secchi = Secchi - (TSS * 0.14)
meanthesis$residual_secchi <- meanthesis$`Secchi (m)` - (meanthesis$`TSS (mg/L)` * 0.14)

# p2 - Regression: residual_secchi vs CDOM a440 (corr)
reg_stats_p2 <- get_regression_stats(meanthesis$`CDOM a440 (corr)`, meanthesis$residual_secchi)

p2 <- ggplot(meanthesis, aes(x = `CDOM a440 (corr)`, y = residual_secchi)) +
  geom_point(color = "gray70") +
  geom_smooth(method = "lm", color = "black", se = FALSE) +
  labs(title = "Residual Secchi vs CDOM", x = "CDOM (m⁻¹)", y = "Residual Secchi (m)") +
  geom_text(x = max(meanthesis$`CDOM a440 (corr)`, na.rm = TRUE), 
            y = max(meanthesis$residual_secchi, na.rm = TRUE), 
            label = paste(reg_stats_p2$eq, "\n", reg_stats_p2$rsq, "\n", reg_stats_p2$pval, "\n", reg_stats_p2$se), 
            hjust = 1, vjust = 1, size = 2, color = "black") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 7, color = "black"),
    axis.line = element_line(colour = "black", size = 0.5),
    axis.title.x = element_text(size = 8, color = "black"),
    axis.title.y = element_text(size = 8, color = "black")
  )

# p3 - Regression: Secchi (m) vs CHLa (ug/L)
reg_stats_p3 <- get_regression_stats(meanthesis$`CHLa (ug/L)`, meanthesis$`Secchi (m)`)
p3 <- ggplot(meanthesis, aes(x = `CHLa (ug/L)`, y = `Secchi (m)`)) +
  geom_point(color = "gray70") +
  geom_smooth(method = "lm", color = "black", se = FALSE) +
  labs(title = "Secchi vs CHLa", x = "CHLa (µg L⁻¹)", y = "Secchi (m)") +
  geom_text(x = max(meanthesis$`CHLa (ug/L)`, na.rm = TRUE), 
            y = max(meanthesis$`Secchi (m)`, na.rm = TRUE), 
            label = paste(reg_stats_p3$eq, "\n", reg_stats_p3$rsq, "\n", reg_stats_p3$pval, "\n", reg_stats_p3$se), 
            hjust = 1, vjust = 2, size = 2, color = "black") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 7, color = "black"),
    axis.line = element_line(colour = "black", size = 0.5),
    axis.title.x = element_text(size = 8, color = "black"),
    axis.title.y = element_text(size = 8, color = "black")
  )

# Display plots in a grid
grid.arrange(p1, p2, p3, ncol = 2)


```


```{r}
# Function to extract regression statistics (equation, R-squared, p-value)
et_regression_stats <- function(x, y) {
  # Remove NA values from both x and y
  data <- na.omit(data.frame(x, y))
  model <- lm(y ~ x, data = data)
  eq <- paste("y = ", round(coef(model)[2], 2), "x + ", round(coef(model)[1], 2), sep = "")
  rsq <- paste("R² = ", round(summary(model)$r.squared, 3), sep = "")
  pval <- paste("p = ", round(summary(model)$coefficients[2, 4], 3), sep = "")
    se <- paste("SE = ", round(summary(model)$coefficients[2, 2], 3), sep = "")  # Extract SE
  return(list(eq = eq, rsq = rsq, pval = pval, se = se))
}

# Perform regression for Secchi vs kd using the 'meanthesis' dataframe
reg_stats_p1 <- et_regression_stats(meanthesis$`Secchi (m)`, meanthesis$`kd (m-1)`)

# Create the plot for Secchi vs kd regression using the 'meanthesis' dataframe
p1 <- ggplot(meanthesis, aes(x = `Secchi (m)`, y = `kd (m-1)`)) +
  geom_point(color = "black") +  # Use a darker gray for points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Black regression line
  labs(title = " ", x = "Secchi Depth (m)", y = "kd (m-1)") +
  geom_text(x = max(meanthesis$`Secchi (m)`, na.rm = TRUE), y = max(meanthesis$`kd (m-1)`, na.rm = TRUE), 
            label = paste(reg_stats_p1$eq, "\n", reg_stats_p1$rsq, "\n", reg_stats_p1$pval, "\n", reg_stats_p1$se), 
            hjust = 1, vjust = 2, size = 3, color = "black") +  # Add the regression equation and stats
  theme_minimal() +
  theme(
    plot.title = element_text(size = 10, color = "black"),  # Title size and color
     axis.line = element_line(colour = "black", size = 0.5),  # Add black axis lines
    axis.title.x = element_text(size = 10, color = "black"),  # X-axis title size and color
    axis.title.y = element_text(size = 10, color = "black"),  # Y-axis title size and color
    axis.text.x = element_text(hjust = 1)  # Rotate x-axis labels for readability
  )

# Print the plot
print(p1)


```

```{r}
# Function to extract regression statistics (equation, R-squared, p-value)
get_regression_stats <- function(x, y) {
  # Remove NA values from both x and y
  data <- na.omit(data.frame(x, y))
  model <- lm(y ~ x, data = data)
  eq <- paste("y = ", round(coef(model)[2], 2), "x + ", round(coef(model)[1], 2), sep = "")
  rsq <- paste("R² = ", round(summary(model)$r.squared, 3), sep = "")
  pval <- paste("p = ", round(summary(model)$coefficients[2, 4], 3), sep = "")
  return(list(eq = eq, rsq = rsq, pval = pval))
}

# Filter data for "Lake Anna"
lake_data <- fullthesis[fullthesis$Lake == "Lake Anna", ]

# Perform regression for Secchi vs kd
reg_stats <- get_regression_stats(lake_data$Secchi, lake_data$kd)

# Create the plot for "Lake Anna"
p <- ggplot(lake_data, aes(x = Secchi, y = kd)) +
  geom_point(color = "gray70") +  # Use a darker gray for points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Black regression line
  labs(title = "Lake Anna: Secchi vs kd", x = "Secchi Depth (m)", y = "kd") +
  geom_text(x = max(lake_data$Secchi, na.rm = TRUE), y = max(lake_data$kd, na.rm = TRUE), 
            label = paste(reg_stats$eq, "\n", reg_stats$rsq, "\n", reg_stats$pval), 
            hjust = 1, vjust = 1, size = 3, color = "black") +  # Add the regression equation and stats
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12, color = "black"),  # Title size and color
    axis.title.x = element_text(size = 10, color = "black"),  # X-axis title size and color
    axis.title.y = element_text(size = 10, color = "black"),  # Y-axis title size and color
    axis.text.x = element_text(angle = 45, hjust = 1)  # Rotate x-axis labels for readability
  ) +
  coord_fixed(ratio = 1)  # Keep the aspect ratio 1:1 for square size

# Display the plot
print(p)

## Briery Creek Lake ______________________________________________

# Function to extract regression statistics (equation, R-squared, p-value)
get_regression_stats <- function(x, y) {
  # Remove NA values from both x and y
  data <- na.omit(data.frame(x, y))
  model <- lm(y ~ x, data = data)
  eq <- paste("y = ", round(coef(model)[2], 2), "x + ", round(coef(model)[1], 2), sep = "")
  rsq <- paste("R² = ", round(summary(model)$r.squared, 3), sep = "")
  pval <- paste("p = ", round(summary(model)$coefficients[2, 4], 3), sep = "")
  return(list(eq = eq, rsq = rsq, pval = pval))
}

# Filter data for "Briery Creek Lake"
lake_data <- fullthesis[fullthesis$Lake == "Briery Creek Lake", ]

# Perform regression for Secchi vs kd
reg_stats <- get_regression_stats(lake_data$Secchi, lake_data$kd)

# Create the plot for "Briery Creek Lake"
p <- ggplot(lake_data, aes(x = Secchi, y = kd)) +
  geom_point(color = "gray70") +  # Use a darker gray for points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Black regression line
  labs(title = "Briery Creek Lake: Secchi vs kd", x = "Secchi Depth (m)", y = "kd") +
  geom_text(x = max(lake_data$Secchi, na.rm = TRUE), y = max(lake_data$kd, na.rm = TRUE), 
            label = paste(reg_stats$eq, "\n", reg_stats$rsq, "\n", reg_stats$pval), 
            hjust = 1, vjust = 1, size = 3, color = "black") +  # Add the regression equation and stats
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12, color = "black"),  # Title size and color
    axis.title.x = element_text(size = 10, color = "black"),  # X-axis title size and color
    axis.title.y = element_text(size = 10, color = "black"),  # Y-axis title size and color
    axis.text.x = element_text(angle = 45, hjust = 1)  # Rotate x-axis labels for readability
  ) +
  coord_fixed(ratio = 1) +  # Keep the aspect ratio 1:1 for square size
  xlim(0, 1.5)  # Set x-axis limits from 0 to 1.5

# Display the plot
print(p)

## Sandy River Reservoir ________________________________________

# Function to extract regression statistics (equation, R-squared, p-value)
get_regression_stats <- function(x, y) {
  # Remove NA values from both x and y
  data <- na.omit(data.frame(x, y))
  model <- lm(y ~ x, data = data)
  eq <- paste("y = ", round(coef(model)[2], 2), "x + ", round(coef(model)[1], 2), sep = "")
  rsq <- paste("R² = ", round(summary(model)$r.squared, 3), sep = "")
  pval <- paste("p = ", round(summary(model)$coefficients[2, 4], 3), sep = "")
  return(list(eq = eq, rsq = rsq, pval = pval))
}

# Filter data for "Sandy River Reservoir"
lake_data <- fullthesis[fullthesis$Lake == "Sandy River Reservoir", ]

# Perform regression for Secchi vs kd
reg_stats <- get_regression_stats(lake_data$Secchi, lake_data$kd)

# Create the plot for "Sandy River Reservoir"
p <- ggplot(lake_data, aes(x = Secchi, y = kd)) +
  geom_point(color = "gray70") +  # Use a darker gray for points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Black regression line
  labs(title = "Sandy River Reservoir: Secchi vs kd", x = "Secchi Depth (m)", y = "kd") +
  geom_text(x = max(lake_data$Secchi, na.rm = TRUE), y = max(lake_data$kd, na.rm = TRUE), 
            label = paste(reg_stats$eq, "\n", reg_stats$rsq, "\n", reg_stats$pval), 
            hjust = 1, vjust = 1, size = 3, color = "black") +  # Add the regression equation and stats
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12, color = "black"),  # Title size and color
    axis.title.x = element_text(size = 10, color = "black"),  # X-axis title size and color
    axis.title.y = element_text(size = 10, color = "black"),  # Y-axis title size and color
    axis.text.x = element_text(angle = 45, hjust = 1)  # Rotate x-axis labels for readability
  ) +
  coord_fixed(ratio = 1) +  # Keep the aspect ratio 1:1 for square size
  xlim(0, 1.5)  # Set x-axis limits from 0 to 1.5

# Display the plot
print(p)

## Fort Barfoot Reservoir _________________________________________

# Function to extract regression statistics (equation, R-squared, p-value)
get_regression_stats <- function(x, y) {
  # Remove NA values from both x and y
  data <- na.omit(data.frame(x, y))
  model <- lm(y ~ x, data = data)
  eq <- paste("y = ", round(coef(model)[2], 2), "x + ", round(coef(model)[1], 2), sep = "")
  rsq <- paste("R² = ", round(summary(model)$r.squared, 3), sep = "")
  pval <- paste("p = ", round(summary(model)$coefficients[2, 4], 3), sep = "")
  return(list(eq = eq, rsq = rsq, pval = pval))
}

# Filter data for "Fort Barfoot Reservoir"
lake_data <- fullthesis[fullthesis$Lake == "Fort Barfoot Reservoir", ]

# Perform regression for Secchi vs kd
reg_stats <- get_regression_stats(lake_data$Secchi, lake_data$kd)

# Create the plot for "Fort Barfoot Reservoir"
p <- ggplot(lake_data, aes(x = Secchi, y = kd)) +
  geom_point(color = "gray70") +  # Use a darker gray for points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Black regression line
  labs(title = "Fort Barfoot Reservoir: Secchi vs kd", x = "Secchi Depth (m)", y = "kd") +
  geom_text(x = max(lake_data$Secchi, na.rm = TRUE), y = max(lake_data$kd, na.rm = TRUE), 
            label = paste(reg_stats$eq, "\n", reg_stats$rsq, "\n", reg_stats$pval), 
            hjust = 1, vjust = 1, size = 3, color = "black") +  # Add the regression equation and stats
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12, color = "black"),  # Title size and color
    axis.title.x = element_text(size = 10, color = "black"),  # X-axis title size and color
    axis.title.y = element_text(size = 10, color = "black"),  # Y-axis title size and color
    axis.text.x = element_text(angle = 45, hjust = 1)  # Rotate x-axis labels for readability
  ) +
  coord_fixed(ratio = 1) +  # Keep the aspect ratio 1:1 for square size
  xlim(0, 1.5)  # Set x-axis limits from 0 to 1.5

# Display the plot
print(p)

## Swift Creek Reservoir ______________________________________

# Function to extract regression statistics (equation, R-squared, p-value)
get_regression_stats <- function(x, y) {
  # Remove NA values from both x and y
  data <- na.omit(data.frame(x, y))
  model <- lm(y ~ x, data = data)
  eq <- paste("y = ", round(coef(model)[2], 2), "x + ", round(coef(model)[1], 2), sep = "")
  rsq <- paste("R² = ", round(summary(model)$r.squared, 3), sep = "")
  pval <- paste("p = ", round(summary(model)$coefficients[2, 4], 3), sep = "")
  return(list(eq = eq, rsq = rsq, pval = pval))
}

# Filter data for "Swift Creek Reservoir"
lake_data <- fullthesis[fullthesis$Lake == "Swift Creek Reservoir", ]

# Perform regression for Secchi vs kd
reg_stats <- get_regression_stats(lake_data$Secchi, lake_data$kd)

# Create the plot for "Swift Creek Reservoir"
p <- ggplot(lake_data, aes(x = Secchi, y = kd)) +
  geom_point(color = "gray70") +  # Use a darker gray for points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Black regression line
  labs(title = "Swift Creek Reservoir: Secchi vs kd", x = "Secchi Depth (m)", y = "kd") +
  geom_text(x = max(lake_data$Secchi, na.rm = TRUE), y = max(lake_data$kd, na.rm = TRUE), 
            label = paste(reg_stats$eq, "\n", reg_stats$rsq, "\n", reg_stats$pval), 
            hjust = 1, vjust = 1, size = 3, color = "black") +  # Add the regression equation and stats
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12, color = "black"),  # Title size and color
    axis.title.x = element_text(size = 10, color = "black"),  # X-axis title size and color
    axis.title.y = element_text(size = 10, color = "black"),  # Y-axis title size and color
    axis.text.x = element_text(angle = 45, hjust = 1)  # Rotate x-axis labels for readability
  ) +
  coord_fixed(ratio = 1) +  # Keep the aspect ratio 1:1 for square size
  xlim(0, 1.5)  # Set x-axis limits from 0 to 1.5

# Display the plot
print(p)

## Harrison Lake ____________________________________________




```

```{r}

# Function to extract regression statistics (equation, R-squared, p-value)
get_regression_stats <- function(x, y) {
  # Remove NA values from both x and y
  data <- na.omit(data.frame(x, y))
  model <- lm(y ~ x, data = data)
  eq <- paste("y = ", round(coef(model)[2], 2), "x + ", round(coef(model)[1], 2), sep = "")
  rsq <- paste("R² = ", round(summary(model)$r.squared, 3), sep = "")
  pval <- paste("p = ", round(summary(model)$coefficients[2, 4], 3), sep = "")
  return(list(eq = eq, rsq = rsq, pval = pval))
}

# Filter data for "Harrison Lake"
lake_data <- fullthesis[fullthesis$Lake == "Harrison Lake", ]

# Perform regression for Secchi vs kd
reg_stats <- get_regression_stats(lake_data$Secchi, lake_data$kd)

# Create the plot for "Harrison Lake"
p <- ggplot(lake_data, aes(x = Secchi, y = kd)) +
  geom_point(color = "gray70") +  # Use a darker gray for points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Black regression line
  labs(title = "Harrison Lake: Secchi vs kd", x = "Secchi Depth (m)", y = "kd") +
  geom_text(x = max(lake_data$Secchi, na.rm = TRUE), y = max(lake_data$kd, na.rm = TRUE), 
            label = paste(reg_stats$eq, "\n", reg_stats$rsq, "\n", reg_stats$pval), 
            hjust = 0, vjust = 1, size = 3, color = "black") +  # Add the regression equation and stats
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12, color = "black"),  # Title size and color
    axis.title.x = element_text(size = 10, color = "black"),  # X-axis title size and color
    axis.title.y = element_text(size = 10, color = "black"),  # Y-axis title size and color
    axis.text.x = element_text(angle = 45, hjust = 1)  # Rotate x-axis labels for readability
  ) +
  coord_fixed(ratio = 1) +  # Keep the aspect ratio 1:1 for square size
  xlim(0, 3)  # Set x-axis limits from 0 to 1


# Display the plot
print(p)

```

```{r}
## Chickahominy Lake____________________________________________
# Function to extract regression statistics (equation, R-squared, p-value)
get_regression_stats <- function(x, y) {
  # Check if there is valid data for both x and y
  if (sum(!is.na(x) & !is.na(y)) < 2) {  # Require at least 2 non-NA points
    return(list(eq = "No data for regression", rsq = "N/A", pval = "N/A"))
  }
  
  # Perform regression with handling for NA values directly in the lm() function
  model <- lm(y ~ x, na.action = na.exclude)  # This will exclude NA values from the regression model
  eq <- paste("y = ", round(coef(model)[2], 2), "x + ", round(coef(model)[1], 2), sep = "")
  rsq <- paste("R² = ", round(summary(model)$r.squared, 3), sep = "")
  pval <- paste("p = ", round(summary(model)$coefficients[2, 4], 3), sep = "")
  return(list(eq = eq, rsq = rsq, pval = pval))
}

# Filter data for "Chickahominy Lake"
lake_data <- fullthesis[fullthesis$Lake == "Chickahominy Lake", ]

# Perform regression for Secchi vs kd
reg_stats <- get_regression_stats(lake_data$Secchi, lake_data$kd)

# Check if regression stats returned valid data
if (reg_stats$eq == "No data for regression") {
  print("Not enough data for regression.")
} else {
  # Create the plot for "Chickahominy Lake"
  p <- ggplot(lake_data, aes(x = Secchi, y = kd)) +
    geom_point(color = "gray70") +  # Use a darker gray for points
    geom_smooth(method = "lm", color = "black", se = FALSE) +  # Black regression line
    labs(title = "Chickahominy Lake: Secchi vs kd", x = "Secchi Depth (m)", y = "kd") +
    geom_text(x = max(lake_data$Secchi, na.rm = TRUE), y = max(lake_data$kd, na.rm = TRUE), 
              label = paste(reg_stats$eq, "\n", reg_stats$rsq, "\n", reg_stats$pval), 
              hjust = 1, vjust = 1, size = 3, color = "black") +  # Add the regression equation and stats
    theme_minimal() +
    theme(
      plot.title = element_text(size = 12, color = "black"),  # Title size and color
      axis.title.x = element_text(size = 10, color = "black"),  # X-axis title size and color
      axis.title.y = element_text(size = 10, color = "black"),  # Y-axis title size and color
      axis.text.x = element_text(angle = 45, hjust = 1)  # Rotate x-axis labels for readability
    ) +
    coord_fixed(ratio = 1) +  # Keep the aspect ratio 1:1 for square size
    xlim(0, 1.5)  # Set x-axis limits from 0 to 1.5

  # Display the plot
  print(p)
}


```

```{r}

pocdataurl <- "https://docs.google.com/spreadsheets/d/e/2PACX-1vSzc4O_yfQyjR6m0xebm0MWcQ58v-aMF1cq1zDVMJ9Qs-tGrgf94j21Ood2xGH-f5hw-gC8CqpjenBO/pub?gid=95641830&single=true&output=csv"

pocdata <- read_csv(pocdataurl)

```

```{r}

# Clean the data by removing rows with NA values in Secchi or Z1% columns
secchi_z1_data_clean <- pocdata[, c("Secchi", "Z1%")]
secchi_z1_data_clean <- secchi_z1_data_clean[!is.na(secchi_z1_data_clean$Secchi) & !is.na(secchi_z1_data_clean$`Z1%`), ]

# Fit the linear regression model for Secchi vs Z1%
model_secchi_z1 <- lm(`Z1%` ~ Secchi, data = secchi_z1_data_clean)

# Extract regression stats (equation, R-squared, p-value)
eq_secchi_z1 <- paste("y = ", round(coef(model_secchi_z1)[2], 2), "x + ", round(coef(model_secchi_z1)[1], 2), sep = "")
rsq_secchi_z1 <- paste("R² = ", round(summary(model_secchi_z1)$r.squared, 3), sep = "")
pval_secchi_z1 <- paste("p = ", round(summary(model_secchi_z1)$coefficients[2, 4], 3), sep = "")

# Create the plot
p_secchi_z1 <- ggplot(secchi_z1_data_clean, aes(x = Secchi, y = `Z1%`)) +
  geom_point(color = "gray70") +  # Use a darker gray for points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Black regression line
  labs(title = " ", x = "Secchi (m)", y = "Z1%") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12, color = "black"),  # Title size and color
     axis.line = element_line(colour = "black", size = 0.5),  # Add black axis lines
    axis.title.x = element_text(size = 10, color = "black"),  # X-axis title size and color
    axis.title.y = element_text(size = 10, color = "black"),  # Y-axis title size and color
    axis.text.x = element_text(angle = 0, hjust = 1)  # Rotate x-axis labels for readability
  ) +
  # Add regression stats to the plot
  geom_text(
    x = max(secchi_z1_data_clean$Secchi, na.rm = TRUE), 
    y = max(secchi_z1_data_clean$`Z1%`, na.rm = TRUE), 
    label = paste(eq_secchi_z1, "\n", rsq_secchi_z1, "\n", pval_secchi_z1), 
    hjust = 1, vjust = 4, size = 3, color = "black"
  ) +
  # Adjust the axis limits (optional, depending on your data range)
  coord_cartesian(xlim = c(min(secchi_z1_data_clean$Secchi, na.rm = TRUE), max(secchi_z1_data_clean$Secchi, na.rm = TRUE)),
                  ylim = c(min(secchi_z1_data_clean$`Z1%`, na.rm = TRUE), max(secchi_z1_data_clean$`Z1%`, na.rm = TRUE)))

# Print the plot
print(p_secchi_z1)



```

## POC

```{r}

get_regression_stats <- function(x, y) {
  model <- lm(y ~ x)
  eq <- paste("y = ", round(coef(model)[2], 2), "x + ", round(coef(model)[1], 2), sep = "")
  rsq <- paste("R² = ", round(summary(model)$r.squared, 3), sep = "")
  pval <- paste("p = ", round(summary(model)$coefficients[2, 4], 3), sep = "")
  se <- paste("SE = ", round(summary(model)$coefficients[2, 2], 3), sep = "")  # Extract SE
  return(list(eq = eq, rsq = rsq, pval = pval, se = se))
}
```



```{r}
# Fit the linear regression model
model <- lm(POC ~ TSS, data = pocdata, na.action = na.exclude)  # This will exclude NA values from the regression model

# Extract regression stats (equation, R-squared, p-value)
eq <- paste("y = ", round(coef(model)[2], 2), "x + ", round(coef(model)[1], 2), sep = "")
rsq <- paste("R² = ", round(summary(model)$r.squared, 3), sep = "")
pval <- paste("p = ", round(summary(model)$coefficients[2, 4], 3), sep = "")
se <- paste("SE = ", round(summary(model)$coefficients[2, 2], 3), sep = "")

# Create the plot
o <- ggplot(pocdata, aes(x = TSS, y = POC)) +
  geom_point(color = "gray70") +  # Use a darker gray for points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Black regression line
  labs(title = "All Station POC vs TSS", x = "TSS (mg L⁻¹)", y = "POC (mgC L⁻¹)" ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12, color = "black"),  # Title size and color
     axis.line = element_line(colour = "black", size = 0.5),  # Add black axis lines
    axis.title.x = element_text(size = 10, color = "black"),  # X-axis title size and color
    axis.title.y = element_text(size = 10, color = "black"),  # Y-axis title size and color
    axis.text.x = element_text(angle = 0, hjust = 1)  # Rotate x-axis labels for readability
  ) +
  # Add regression stats to the plot
  geom_text(
    x = max(pocdata$TSS, na.rm = TRUE), 
    y = max(pocdata$POC, na.rm = TRUE), 
    label = paste(eq, "\n", rsq, "\n", pval), 
    hjust = 1, vjust = 3, size = 3, color = "black"
  ) +
  coord_fixed(ratio = 6)

print(o)


```

```{r}


# Fit the linear regression model for CHLa vs POC
model_chla_poc <- lm(POC ~ CHLa, data = pocdata, na.action = na.exclude)  # Exclude NA values from the regression model

# Extract regression stats (equation, R-squared, p-value)
eq_chla_poc <- paste("y = ", round(coef(model_chla_poc)[2], 2), "x + ", round(coef(model_chla_poc)[1], 2), sep = "")
rsq_chla_poc <- paste("R² = ", round(summary(model_chla_poc)$r.squared, 3), sep = "")
pval_chla_poc <- paste("p = ", round(summary(model_chla_poc)$coefficients[2, 4], 3), sep = "")
se <- paste("SE = ", round(summary(model_chla_poc)$coefficients[2, 2], 3), sep = "")

# Create the plot
p_chla_poc <- ggplot(pocdata, aes(x = CHLa, y = POC)) +
  geom_point(color = "gray10") +  # Use a darker gray for points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Black regression line
  labs(title = "All Station POC vs CHLa", x = "CHLa (µg L⁻¹)", y = "POC (mgC L⁻¹)") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12, color = "black"),  # Title size and color
     axis.line = element_line(colour = "black", size = 0.5),  # Add black axis lines
    axis.title.x = element_text(size = 10, color = "black"),  # X-axis title size and color
    axis.title.y = element_text(size = 10, color = "black"),  # Y-axis title size and color
    axis.text.x = element_text(angle = 45, hjust = 1)  # Rotate x-axis labels for readability
  ) +
  # Add regression stats to the plot
  geom_text(
    x = max(pocdata$CHLa, na.rm = TRUE), 
    y = max(pocdata$POC, na.rm = TRUE), 
    label = paste(eq_chla_poc, "\n", rsq_chla_poc, "\n", pval_chla_poc, "\n", se), 
    hjust = 1, vjust = 4, size = 3, color = "black"
  ) +
  coord_fixed(ratio = 10)

# Print the plot
p_chla_poc


```


```{r}

# Assuming 'pocdata' has a 'Site' column that identifies the site

# Calculate the site averages for POC and TSS
site_averages <- pocdata %>%
  group_by(Site) %>%
  summarise(
    avg_TSS = mean(TSS, na.rm = TRUE),
    avg_CHLA = mean(CHLa, na.rm = TRUE),
    avg_POC = mean(POC, na.rm = TRUE)
  )

# Fit the linear regression model using site averages
model <- lm(avg_POC ~ avg_TSS, data = site_averages, na.action = na.exclude)

# Extract regression stats (equation, R-squared, p-value, and residual SE)
eq <- paste("y = ", round(coef(model)[2], 2), "x + ", round(coef(model)[1], 2), sep = "")
rsq <- paste("R² = ", round(summary(model)$r.squared, 3), sep = "")
pval <- paste("p = ", round(summary(model)$coefficients[2, 4], 3), sep = "")
se <- paste("SE = ", round(summary(model)$coefficients[2, 2], 3), sep = "")

# Create the plot with site averages
t <- ggplot(site_averages, aes(x = avg_TSS, y = avg_POC)) +
  geom_point(color = "gray10") +  # Use a darker gray for points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Black regression line
  labs(title = "Site Average POC vs TSS", x = "TSS (mg L⁻¹)", y = "POC (mgC L⁻¹)") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12, color = "black"),  # Title size and color
     axis.line = element_line(colour = "black", size = 0.5),  # Add black axis lines
    axis.title.x = element_text(size = 10, color = "black"),  # X-axis title size and color
    axis.title.y = element_text(size = 10, color = "black"),  # Y-axis title size and color
    axis.text.x = element_text(angle = 0, hjust = 1)  # Rotate x-axis labels for readability
  ) +
  # Add regression stats to the plot (equation, R², p-value, and SE)
  geom_text(
    x = max(site_averages$avg_TSS, na.rm = TRUE), 
    y = max(site_averages$avg_POC, na.rm = TRUE), 
    label = paste(eq, "\n", rsq, "\n", pval, "\n", se), 
    hjust = 1, vjust = 3, size = 3, color = "black"
  ) +
  coord_fixed(ratio = 6)

print(t)


```

```{r}

model <- lm(avg_POC ~ avg_CHLA, data = site_averages, na.action = na.exclude)

# Extract regression stats (equation, R-squared, p-value, and residual SE)
eq <- paste("y = ", round(coef(model)[2], 2), "x + ", round(coef(model)[1], 2), sep = "")
rsq <- paste("R² = ", round(summary(model)$r.squared, 3), sep = "")
pval <- paste("p = ", round(summary(model)$coefficients[2, 4], 3), sep = "")
se <- paste("SE = ", round(summary(model)$coefficients[2, 2], 3), sep = "")

c <- ggplot(site_averages, aes(x = avg_CHLA, y = avg_POC)) +
  geom_point(color = "gray10") +  # Use a darker gray for points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Black regression line
  labs(title = "Site Average POC vs CHLa", x = "CHLa (ug L⁻¹)", y = "POC (mgC L⁻¹)") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12, color = "black"),  # Title size and color
     axis.line = element_line(colour = "black", size = 0.5),  # Add black axis lines
    axis.title.x = element_text(size = 10, color = "black"),  # X-axis title size and color
    axis.title.y = element_text(size = 10, color = "black"),  # Y-axis title size and color
    axis.text.x = element_text(angle = 0, hjust = 1)  # Rotate x-axis labels for readability
  ) +
  # Add regression stats to the plot (equation, R², p-value, and SE)
  geom_text(
    x = max(site_averages$avg_CHLA, na.rm = TRUE), 
    y = max(site_averages$avg_POC, na.rm = TRUE), 
    label = paste(eq, "\n", rsq, "\n", pval, "\n", se), 
    hjust = 1, vjust = 3, size = 3, color = "black"
  ) +
  coord_fixed(ratio = 15)

print(c)

```

```{r}

pocdata <- pocdata %>%
  mutate(OrganicFraction_TSS = (POC * 2) / TSS)

pocdata <- pocdata %>%
  mutate(MyOrganicFraction_TSS = (POC) / TSS)

# Print the first few rows to check the new column

```


```{r}

# Fit the linear regression model
model <- lm(OrganicFraction_TSS ~ TSS, data = pocdata, na.action = na.exclude)  # This will exclude NA values from the regression model

# Extract regression stats (equation, R-squared, p-value)
eq <- paste("y = ", round(coef(model)[2], 2), "x + ", round(coef(model)[1], 2), sep = "")
rsq <- paste("R² = ", round(summary(model)$r.squared, 3), sep = "")
pval <- paste("p = ", round(summary(model)$coefficients[2, 4], 3), sep = "")

# Create the plot
p <- ggplot(pocdata, aes(x = TSS, y = OrganicFraction_TSS)) +
  geom_point(color = "gray70") +  # Use a darker gray for points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Black regression line
  labs(title = "All Station OrganicFraction_TSS vs TSS", x = "TSS (mg⁻ᴸ)", y = "Organic Fraction to TSS Ratio") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12, color = "black"),  # Title size and color
    axis.title.x = element_text(size = 10, color = "black"),  # X-axis title size and color
    axis.title.y = element_text(size = 10, color = "black"),  # Y-axis title size and color
    axis.text.x = element_text(angle = 0, hjust = 1)  # Rotate x-axis labels for readability
  ) +
  # Add regression stats to the plot
  geom_text(
    x = max(pocdata$TSS, na.rm = TRUE), 
    y = max(pocdata$OrganicFraction_TSS, na.rm = TRUE), 
    label = paste(eq, "\n", rsq, "\n", pval), 
    hjust = 1, vjust = 3, size = 3, color = "black"
  ) +
  coord_fixed(ratio = 6)

# Print the plot
print(p)


```


```{r}


# Create a new data frame with only TSS and C% columns
tss_c_data <- pocdata[, c("TSS", "C%")]

tss_c_data_clean <- tss_c_data[!is.na(tss_c_data$TSS) & !is.na(tss_c_data$`C%`), ]

```

```{r}
# Keep the original C% as a percentage (no conversion)
# Clean the data by removing rows with NA values in TSS or C% columns
tss_c_data_clean <- pocdata[, c("TSS", "C%")]
tss_c_data_clean <- tss_c_data_clean[!is.na(tss_c_data_clean$TSS) & !is.na(tss_c_data_clean$`C%`), ]

# Check the data range
summary(tss_c_data_clean)

# Fit the linear regression model for TSS vs C%
model_tss_c <- lm(`C%` ~ TSS, data = tss_c_data_clean)

# Extract regression stats (equation, R-squared, p-value)
eq_tss_c <- paste("y = ", round(coef(model_tss_c)[2], 2), "x + ", round(coef(model_tss_c)[1], 2), sep = "")
rsq_tss_c <- paste("R² = ", round(summary(model_tss_c)$r.squared, 3), sep = "")
pval_tss_c <- paste("p = ", round(summary(model_tss_c)$coefficients[2, 4], 3), sep = "")

# Create the plot
p_tss_c <- ggplot(tss_c_data_clean, aes(x = TSS, y = `C%`)) +
  geom_point(color = "gray70") +  # Use a darker gray for points
  geom_smooth(method = "lm", color = "black", se = FALSE) +  # Black regression line
  labs(title = "All Station C% vs TSS", x = "TSS (mg/L)", y = "C%") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12, color = "black"),  # Title size and color
    axis.title.x = element_text(size = 10, color = "black"),  # X-axis title size and color
    axis.title.y = element_text(size = 10, color = "black"),  # Y-axis title size and color
    axis.text.x = element_text(angle = 45, hjust = 1)  # Rotate x-axis labels for readability
  ) +
  # Add regression stats to the plot
  geom_text(
    x = max(tss_c_data_clean$TSS, na.rm = TRUE), 
    y = max(tss_c_data_clean$`C%`, na.rm = TRUE), 
    label = paste(eq_tss_c, "\n", rsq_tss_c, "\n", pval_tss_c), 
    hjust = 1, vjust = 2, size = 3, color = "black"
  ) +
  # Adjust the y-axis to go from 0 to 80
  coord_cartesian(xlim = c(min(tss_c_data_clean$TSS, na.rm = TRUE), max(tss_c_data_clean$TSS, na.rm = TRUE)),
                  ylim = c(0, 80))  # Set y-axis limits from 0 to 80

# No need to use print(), the plot will automatically be shown in RStudio
p_tss_c  # Simply run this and the plot will be shown


```


```{r}


# Calculate the average C% for each site
avg_cpercent <- pocdata %>%
  group_by(Site) %>%  # Group by Site
  summarize(Average_Cpercent = mean(`C%`, na.rm = TRUE)) %>%
  filter(!is.na(Average_Cpercent))  # Filter out sites with no valid C% data

# Create a bar plot to show the average C% by site
p <- ggplot(avg_cpercent, aes(x = Site, y = Average_Cpercent)) + 
  geom_bar(stat = "identity", fill = "steelblue") +  # Bar plot with bars filled in steelblue
  labs(title = "Average C% by Site", x = "Site", y = "Average C%") +  # Labels for the plot
  theme_minimal() +  # Minimal theme for clean look
  theme(
    plot.title = element_text(size = 12, color = "black"),  # Customize title size and color
    axis.title.x = element_text(size = 10, color = "black"),  # X-axis title customization
    axis.title.y = element_text(size = 10, color = "black"),  # Y-axis title customization
    axis.text.x = element_text(angle = 45, hjust = 1)  # Rotate x-axis labels for better readability
  )

# Print the plot
print(p)



```

```{r}

# Create a bar plot to show the average C% by site
p <- ggplot(avg_cpercent, aes(x = Site, y = Average_Cpercent)) + 
  geom_bar(stat = "identity", fill = "steelblue") +  # Bar plot with bars filled in steelblue
  labs(title = "Average C% by Site", x = "Site", y = "Average C%") +  # Labels for the plot
  theme_minimal() +  # Minimal theme for clean look
  theme(
    plot.title = element_text(size = 12, color = "black"),  # Customize title size and color
    axis.title.x = element_text(size = 10, color = "black"),  # X-axis title customization
    axis.title.y = element_text(size = 10, color = "black"),  # Y-axis title customization
    axis.text.x = element_text(angle = 45, hjust = 1)  # Rotate x-axis labels for better readability
  ) +
  # Set the y-axis limit to 100
  scale_y_continuous(limits = c(0, 100))

# Print the plot
print(p)


```


```{r}

# Calculate the average C% and standard error for each site
avg_cpercent <- pocdata %>%
  group_by(Site) %>%  # Group by Site
  summarize(
    Average_Cpercent = mean(`C%`, na.rm = TRUE),
    SE_Cpercent = sd(`C%`, na.rm = TRUE) / sqrt(n())  # Standard error calculation
  ) %>%
  filter(!is.na(Average_Cpercent))  
```


```{r}

# Define desired site order
site_order <- c("Harrison", "Chick", "BRI_1", "BRI_2", "SDY_1", "SDY_2", "SDY_3", 
                "SFT_1", "SFT_2", "SFT_3", "SFT_4", "Barfoot", "ANNA")

# Recode Site names in avg_cpercent to match those used in meanthesis_long
avg_cpercent <- avg_cpercent %>%
  mutate(
    Site = dplyr::recode(Site, 
                         "2-BRI010.78" = "BRI_1",
                         "2-BRI013.12" = "BRI_2",
                         "5ANTW127.14" = "Barfoot",
                         "2-CHK026.94" = "Chick",
                         "Harrison Near Dam" = "Harrison",
                         "2-SDY004.27" = "SDY_1",
                         "2-SDY005.85" = "SDY_2",
                         "2-MBN000.96" = "SDY_3",
                         "2-SFT031.08" = "SFT_1",
                         "2-DYC000.19" = "SFT_2",
                         "2-SFT033.42" = "SFT_3",
                         "2-SFT034.38" = "SFT_4",
                         "Lake Anna Dam Surface" = "ANNA")
  ) %>%
  # Set Site as a factor with the specified order
  mutate(Site = factor(Site, levels = site_order)) %>%
  arrange(Site)  # Optional: for readability

# Plot with updated Site order
p <- ggplot(avg_cpercent, aes(x = Site, y = Average_Cpercent)) + 
  geom_bar(stat = "identity", fill = "steelblue") +  
  geom_errorbar(
    aes(ymin = Average_Cpercent - SE_Cpercent, ymax = Average_Cpercent + SE_Cpercent),
    width = 0.2,
    color = "black"
  ) +
  labs(title = "Average C% by Site", x = "Site", y = "Average C%") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 12, color = "black"),
     axis.line = element_line(colour = "black", size = 0.5),
    axis.title.x = element_text(size = 10, color = "black"),
    axis.title.y = element_text(size = 10, color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  ) +
  scale_y_continuous(limits = c(0, 100))

# Print the plot
print(p)

```

